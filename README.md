# drx - dynamic reactive programming

*Reactive Programming without (memory) leaks.*

drx is a library for reactive programming with Scala and Scala.js. Reactive programming is modeled as a directed acyclic graph -- where nodes do computations and send messages to successors and listen to their predecessors. In this implementation, you can create reactive graphs at runtime (dynamically) and it works well with garbage collection -- meaning reactives which are not needed anymore for the program to function are collected.

In contrast to Scala.React and REScala, we only use features that are available on the web (no weak references, no finalizers).

In contrast, to React and ReactiveExtensions you do not have to explicitly disconnect most reactives, instead many reactives are automatically collected if no longer used. Only output reactives (observers) -- which are not pure and used to have information leave the reactive library and communicate back to your program -- have to be explicitely disconnected. The rest of the reactive graph can be handled declaratively -- e.g. without disconnecting it explicitly.

This is done, by implementing 'lazy propagation' as described by Petricek and Syme in 'Collecting Hollywoods Garbage': In summary, for lazy propagation the reactive graph is constructed of mostly backwards-references, and only those nodes which ultimately lead to an output of the graph (observers / sinks), are also connected with forward-references. Information can the flow over the forward edges to the outputs, ignoring the nodes which do not lead to an output. The unconnected nodes are free to be collected by a garbage collector, if no longer referenced anywhere else.

In contrast to Flapjax and Scala.Rx, our method does not expect all dynamism to be generated by switches / inside signals.

Other features:
* glitch-avoidance via topological sort
* folds ( but must be disconnected explicitly like outputs :( )
* two example applications to create, edit and delete todos, one running on JS and one for the JVM.

Run the web example:
~~~
sbt todojs/fastOptJS # compile
firefox index.html   # open app in browser
~~~

Note, that with some browsers you can not open local web pages. In this case, you can use python to serve the page to localhost:
~~~
python3 -m http.server 8000
chromium-browser "http://localhost:8000"
~~~

Run the JavaFX example:
~~~
# ... first install jfxrt.jar somehow ...!
sbt todofx/run
~~~

